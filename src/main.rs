mod logic {
    pub mod game;
    pub mod min_max;
}

use std::cell::RefCell;
// use std::path::Path;
use std::rc::Rc;

use adw::Application;
use adw::prelude::*;
use gtk;
// use gtk::prelude::GridExt;
// use gtk::gdk::Texture;
// use gtk::gdk_pixbuf::Pixbuf;

use crate::logic::game::Game;
use crate::logic::game::PlayParams;
use crate::logic::game::Players;

fn main() {
    let app = Application::builder().application_id(APP_ID).build();

    app.connect_activate(|app| {
        // ✅ Load the CSS file
        let provider = gtk::CssProvider::new();
        provider.load_from_path("src/ui/style.css");

        // ✅ Apply globally
        gtk::style_context_add_provider_for_display(
            &gtk::gdk::Display::default().expect("Could not connect to display"),
            &provider,
            gtk::STYLE_PROVIDER_PRIORITY_APPLICATION,
        );

        // Load ui file
        let builder = gtk::Builder::from_file("target/ui/window.ui");
        let window: gtk::ApplicationWindow = builder
            .object("main_window")
            .expect("Couldn't get window with id \"main_window\"");

        let game: Game = Game::default();
        let game_rc: Rc<RefCell<Game>> = Rc::new(RefCell::new(game));
        let box_grid: gtk::Grid = builder.object("box_frame").unwrap();

        //===========================
        // Get neccessery widget
        //===========================
        let player: gtk::Image = builder.object("player").unwrap();
        let player_win_round: gtk::Label = builder.object("player-win-round").unwrap();

        // Bot Var
        let bot: gtk::Image = builder.object("bot").unwrap();
        let bot_win_round: gtk::Label = builder.object("bot-win-round").unwrap();

        // Turn Indicator
        let turn_indicator: gtk::Label = builder.object("turn-indicator").unwrap();

        // Reset Btn
        let reset_button: gtk::Button = builder.object("reset_btn").unwrap();

        populate_board(
            &game_rc,
            &player,
            &player_win_round,
            &bot,
            &bot_win_round,
            &turn_indicator,
            &box_grid,
        );

        // Bye, time for bed :)

        reset_button.connect_clicked(|_| {
            // game = Game::default();
        });

        //===================
        // Present Window
        //===================
        window.set_application(Some(app));
        window.present();
    });

    //===========================
    //
    //===========================
    // fn x_o_box_fn(x: i32, y: i32, player: &Players, image: &gtk::Image) {
    // game.play(PlayParams { x, y, val: player });
    // image.set_from_file(get_nxt_card(&game.player_1));
    // }

    app.run();
}

//===========================
// CONSTAINT VARIABLE
//===========================
const X_IMG_PATH: &str = "assets/icons/x.png";
const O_IMG_PATH: &str = "assets/icons/o.png";
const APP_ID: &str = "dev.mc-stephen.tic-tac-toe";

//===========================
// Generated by Ai
//===========================
// fn resize_img(file_path: &Path, target_width: i32, target_height: i32) -> Texture {
//     // 1. Load and scale the image using GdkPixbuf
//     let scaled_pixbuf = Pixbuf::from_file_at_scale(
//         file_path,
//         target_width,  // The maximum width
//         target_height, // The maximum height
//         true,          // Preserve the aspect ratio (crucial for clean scaling)
//     )
//     .expect("Could not load and scale pixbuf. Check file path.");

//     // The Pixbuf has now been scaled down to its new, smaller dimensions.
//     let actual_width = scaled_pixbuf.width();
//     let actual_height = scaled_pixbuf.height();

//     // 2. Convert the scaled Pixbuf to a GdkTexture (the modern Paintable)
//     let texture: Texture = Texture::for_pixbuf(&scaled_pixbuf);

//     // 3. Create the GtkPicture and enforce the fixed size
//     let picture = gtk::Picture::builder()
//         .paintable(&texture)
//         // Explicitly request the widget to be the exact size of the scaled image.
//         // This is how you enforce a 'fixed size' on the GtkPicture.
//         .width_request(actual_width)
//         .height_request(actual_height)
//         // Center the image if the parent container is larger than the fixed size
//         .halign(gtk::Align::Center)
//         .valign(gtk::Align::Center)
//         .build();

//     texture
// }

// fn set_scaled_picture(
//     picture_widget: &gtk::Image,
//     file_path: &Path,
//     target_width: i32,
//     target_height: i32,
// ) {
//     // 1. Load and scale the image using GdkPixbuf
//     let scaled_pixbuf = match Pixbuf::from_file_at_scale(
//         file_path,
//         target_width,
//         target_height,
//         true, // Preserve aspect ratio
//     ) {
//         Ok(pb) => pb,
//         Err(e) => {
//             eprintln!("Error loading or scaling image: {}", e);
//             return;
//         }
//     };

//     // 2. Get the actual dimensions of the scaled image
//     let actual_width = scaled_pixbuf.width();
//     let actual_height = scaled_pixbuf.height();

//     // 3. Convert the scaled Pixbuf to a GdkTexture (Paintable)
//     let texture = Texture::for_pixbuf(&scaled_pixbuf);

//     // 4. Apply the new content to the existing GtkPicture widget
//     picture_widget.set_paintable(Some(&texture));
//     // picture_widget.set_can_shrink(true);
//     picture_widget.set_size_request(actual_width, actual_height);
//     // 5. Apply the fixed-size constraints to the existing GtkPicture widget
//     // picture_widget.set_width_request(actual_width);
//     // picture_widget.set_height_request(actual_height);
// }

//===========================
//
//===========================
fn get_card(player: &Players) -> Option<&'static str> {
    return match player {
        Players::X => Some(X_IMG_PATH),
        Players::O => Some(O_IMG_PATH),
    };
}

//===========================
// Update state
//===========================
// fn update_state(
// game: &Rc<RefCell<Game>>,
// player: &gtk::Image,
// player_win_round: &gtk::Label,
// bot: &gtk::Image,
// bot_win_round: &gtk::Label,
// turn_indicator: &gtk::Label,
// box_grid: &gtk::Grid,
// ) {
//     // let update_state = || {
//     // ==
//     player_win_round.set_label(&game.borrow().player_1_win_count.to_string());
//     player.set_from_file(get_card(&game.borrow().player_1));

//     // ==
//     bot_win_round.set_label(&game.borrow().player_2_win_count.to_string());
//     bot.set_from_file(get_card(&game.borrow().player_2));

//     // ==
//     turn_indicator.set_label(if game.borrow().now_playing == game.borrow().player_1 {
//         "Your Turn"
//     } else {
//         "Bot Turn"
//     });

//     // ==
//     populate_board(game, box_grid);
// }

//===========================
// Auto populate grid cells
//===========================
fn populate_board(
    game_rc: &Rc<RefCell<Game>>, // Changed name to 'game_rc' for clarity
    player: &gtk::Image,
    player_win_round: &gtk::Label,
    bot: &gtk::Image,
    bot_win_round: &gtk::Label,
    turn_indicator: &gtk::Label,
    box_grid: &gtk::Grid,
) {
    clear_grid_children(box_grid); // Pass the reference directly

    // Get an immutable borrow once for UI setup
    let game_state = game_rc.borrow();

    // == Update Player/Bot info
    player_win_round.set_label(&game_state.player_1_win_count.to_string());
    player.set_from_file(get_card(&game_state.player_1));

    bot_win_round.set_label(&game_state.player_2_win_count.to_string());
    bot.set_from_file(get_card(&game_state.player_2));

    // == Update Turn Indicator
    turn_indicator.set_label(if game_state.now_playing == game_state.player_1 {
        "Your Turn"
    } else {
        "Bot Turn"
    });

    //========== Loop to create cells
    for y in 0..game_state.board.len() {
        for x in 0..game_state.board[y].len() {
            let image: gtk::Image = gtk::Image::new();
            let x_o_box: gtk::Box = gtk::Box::builder().build();
            let gesture: gtk::GestureClick = gtk::GestureClick::new();

            // ... Box setup ...
            x_o_box.append(&image);
            x_o_box.add_css_class("single");
            x_o_box.add_css_class(&format!("cell-{y}{x}"));
            x_o_box.set_widget_name(&format!("cell-{y}{x}"));

            // ... Image setup ...
            image.set_hexpand(true);
            image.set_halign(gtk::Align::Center);
            image.set_size_request(70, 70);

            // == Attach to grid
            box_grid.attach(&x_o_box, x as i32, y as i32, 1, 1);

            //== Draw existing marks
            if let Some(player_mark) = game_state.board[y][x] {
                // Use the single game_state borrow
                if player_mark == game_state.player_1 {
                    image.set_from_file(get_card(&game_state.player_1));
                }
                if player_mark == game_state.player_2 {
                    image.set_from_file(get_card(&game_state.player_2));
                }
            }

            // --- Capture Variables for Closure (Crucial Fixes Below) ---

            // 1. Clone the necessary handles for the closure to OWN
            let game_rc_clone = game_rc.clone();

            // 2. Clone the necessary widgets for the recursive call to accept
            let player_clone = player.clone();
            let player_win_round_clone = player_win_round.clone();
            let bot_clone = bot.clone();
            let bot_win_round_clone = bot_win_round.clone();
            let turn_indicator_clone = turn_indicator.clone();
            let box_grid_clone = box_grid.clone();

            // 3. Prepare simple data for the play call
            let x_val = x as i32; // x and y are i32 implicitly when used in range/indexing, no clone needed
            let y_val = y as i32;
            let player_1_mark = game_state.player_1; // Game state is borrowed once

            // ===
            gesture.connect_released(move |_, _, _, _| {
                // Must use the cloned handles inside the closure

                // 1. Mutate the game state
                let mut game_borrow = game_rc_clone.borrow_mut();
                game_borrow.play(PlayParams {
                    x: x_val, // x_val and y_val are owned by the closure
                    y: y_val,
                    val: player_1_mark, // player_1_mark is owned by the closure
                });
                drop(game_borrow); // Explicitly drop borrow before recursive call

                // 2. Call the function recursively using REFERENCES to the cloned handles
                populate_board(
                    &game_rc_clone,
                    &player_clone, // Passed by reference to the cloned handle
                    &player_win_round_clone,
                    &bot_clone,
                    &bot_win_round_clone,
                    &turn_indicator_clone,
                    &box_grid_clone,
                );
            });
            x_o_box.add_controller(gesture);
        }
    }
}

//===========================
// Auto populate grid cells
//===========================
fn clear_grid_children(grid: &gtk::Grid) {
    // Start with the first child.
    let mut child = grid.first_child();

    // Loop until the child pointer becomes None (the last one is removed).
    while child.is_some() {
        let current_child = child.unwrap();

        // Store the next sibling *before* removing the current child.
        // This is crucial because removing the child invalidates its sibling relationship.
        let next = current_child.next_sibling();

        // Remove the child from the grid.
        grid.remove(&current_child);

        // Move to the next widget in the list.
        child = next;
    }
}
